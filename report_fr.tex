\documentclass[12pt]{article}

\setlength{\parskip}{1em}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{slantsc}
\usepackage{graphicx}
\usepackage[a4paper, margin=1in]{geometry}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue,
  pdftitle={Projet LO21: Rapport final}
}

\usepackage{listings}
\lstset{
  numbers=left,
  columns=fullflexible,
  language=C,
  numberstyle=\scriptsize,
}

\usepackage[linesnumbered, french]{algorithm2e}
\SetKwInput{Data}{Donn\'ees}
\SetKwInput{Result}{R\'esultat}
\SetKwInput{Vars}{Variables}
\SetKwIF{If}{ElseIf}{Else}{Si}{alors}{Sinon si}{Sinon}{FinSi}
\SetKwFor{While}{Tant que}{faire}{Fin TantQue}
\SetKwBlock{Begin}{D\'ebut}{Fin}
\DontPrintSemicolon
\SetAlgoLined

\RestyleAlgo{boxruled}

\newcommand{\Assign}[2]{#1 $\; \longleftarrow \;$ #2}
\newcommand{\Arg}[2]{\hspace{0.2em}#1\hspace{0.05em}: #2}
% \newcommand{\Child}[2]{(#1 $\rightarrow$ #2)}
\newcommand{\Child}[2]{#2(#1)}
\newcommand{\Null}[0]{\textsc{null}\hspace{4pt}}

\renewcommand{\arraystretch}{1.5}

\title{Projet LO21: Rapport final}
\author{Adrien Burgun}
\date{Automne 2020}
\graphicspath{{report/}}

\begin{document}

\maketitle

\begin{abstract}

  Le projet de ce semestre pour le cours de \textbf{LO21} (Algorithmique et Programmation II) porte sur un \textit{\og système expert \fg}.
  Un système expert est constitué de 3 éléments:

  \begin{description}[align=left]
    \item [Une base de connaissance,] qui prend la forme suivante:
    \[
      A \wedge B \wedge ... \wedge Z \Rightarrow \Omega
    \]
    Où \(A, B, ...\) sont les symboles (d'arité zéro, aussi appelés \og propositions \fg) constituant la \textit{prémisse} et \(\Omega\) est la \textit{conclusion}.

    \item [Une base de faits,] qui est la liste des symboles ayant la valeur \textit{\og Vrai \fg} (qui correspond à l'état \textit{\og Certain \fg}). \\
    Un symbole ne faisant pas partie de cette liste a par défaut la valeur \textit{\og Faux \fg} (qui correspond à l'état \textit{\og Incertain \fg}).

    \item [Un moteur d'inférence,] qui, à partir de la base de connaissance et la base de faits, déduit quels autres symboles sont aussi vrais et les ajoute à la base de faits.
  \end{description}

  Nous définirons d'abords le type \textit{\og Règle \fg}, constituant la base de connaissance. \\
  Nous définirons ensuite le type \textit{\og BC \fg} (\underline{B}ase de \underline{C}onnaissance). \\
  Nous décrirons enfin le moteur d'inférence comme implémenté dans ce projet, avec différents exemples.
\end{abstract}

\newpage

% 1
\section{Règles}

Soit \textbf{Règle} le type représentant une règle sous la forme d'une liste chaînée de symboles:

% Faire un tableau?

% \begin{lstlisting}
% #define LONGUEUR_SYMBOLE 256

% struct regle {
%   char symbole[LONGUEUR_SYMBOLE];
%   struct regle* suivant;
% };

% typedef struct regle regle_t;
% \end{lstlisting}

\begin{tabular}{|p{3cm}|p{4cm}|p{6.5cm}|}
  \hline
  \multicolumn{3}{|c|}{\textbf{Structure 1 :} Règle\label{R}} \\
  \hline
  \textbf{Nom} & \textbf{Type} & \textbf{Description} \\
  \hline
  \textit{symbole} & Règle $\rightarrow$ Chaîne de charactères & Retourne le nom du symbole correspondant au noeud en tête de liste. \\
  \hline
  \textit{suivant} & Règle $\rightarrow$ Règle & Retourne une référence au prochain élément de la liste chaînée, \textit{règle\_vide} si l'élément est le dernier de la liste. \\
  \hline
  \textit{nouvelle\_règle} & ((Chaîne de charactères) $\times$ Règle) $\rightarrow$ Règle & Compose une nouvelle règle à partir du nom d'un symbole et une référence à la prochaine règle. \\
  \hline
  \textit{règle\_vide} & Règle & La règle vide. \\
  \hline
  \textit{mettre\_suivant} & (Règle $\times$ Règle) $\rightarrow$ Règle & Modifie une Règle pour y attacher une Règle comme règle suivante; retourne également la règle modifiée. \\
  \hline
\end{tabular}

Le dernier élément d'une telle liste chaînée correspond à la conclusion de la règle, tandis que tous les autres éléments appartiennent à la prémisse (contrainte du projet).

Les axiomes sur ces fonctions sont:

\begin{itemize}
\item \textit{symbole}(\textit{nouvelle\_règle}(s, r)) = s
\item \textit{suivant}(\textit{nouvelle\_règle}(s, r)) = r
\item \Assign{A}{\textit{nouvelle\_règle}(s, r)}; \textit{mettre\_suivant}(a, r') $\; \Rightarrow$ \textit{suivant}(A) = r'
\end{itemize}

% 1.1
\subsection{Créer une règle vide}

Nous représentons une règle vide par \textit{règle\_vide}.
Voici l'algorithme permettant de créer une règle vide:

\begin{algorithm}[H]
\Vars{\Arg{$R$}{La règle vide à retourner}}
\Result{\Arg{$R$}{Règle}}

\Begin({RègleVide()}){
  \Assign{$R$}{\textit{règle\_vide}}
}

\caption{RègleVide\label{RV}}
\end{algorithm}

% 1.2
\subsection{Ajouter une proposition à la prémisse d'une règle}

% Je me permets d'interrompre votre brave lecture de ce document latex pour argumenter sur la question posée dans le sujet original, qui stipule que cet ajout doit se faire en *queue*, et non pas en *tête*.
% Voici donc des exemples d'utilisations de cette fonction et les résultats auxquels on s'attendrait (1) par rapport aux résultats qu'on obtiendra avec cette contrainte (2):
%
% ajout_prémisse(ø, A) -> (1) A | ø, (2) ø | A
% ajout_prémisse(ø | A, B) -> (1) B | A; (2) A | B
% ajout_prémisse(A & B | Ω, C) -> (1) C & A & B | Ω; (2) A & B & Ω | C
%
% Le problème est, à mon avis, qu'ajouter un symbole à la prémisse d'une règle ne devrait pas affecter la conclusion d'une règle, ce qui n'est pas le cas lorsque l'ajout se fait à l'endroit dédié à la conclusion de la règle.
% Cela voudra aussi dire que la fonction pour ajouter une conclusion à une règle sera identique à celle-ci.

L'ajout des propositions (symboles) à la prémisse d'une règle se fait par l'algorithme \textit{AjoutPrémisse} défini ci-dessous.
Cet ajout se fait en queue de la liste chaînée (contrainte du projet).
La liste chaînée donnée en entrée est modifiée par l'algorithme et est retournée.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à modifier} \\
  \Arg{$R'$}{Une variable temporaire pour traverser la liste chaînée} \\
  \Arg{\textit{symbole}}{Le nom de la proposition (symbole) à insérer}
}
\Data{\Arg{$R$}{Règle}, \Arg{\textit{symbole}}{Chaîne de charactères}}
\Result{\Arg{$R$}{Règle}}

\Begin({AjoutPrémisse($R$, \textit{symbole})}){
  \uIf{$R$ = \textit{règle\_vide}}{
    \Assign{$R$}{\textit{nouvelle\_règle}(\textit{symbole}, \textit{règle\_vide})}
  }
  \Else{
    \Assign{$R'$}{R}

    \tcp{Répeter jusqu'à ce qu'on atteigne le dernier élément}

    \While{\Child{$R'$}{\textit{suivant}} $\neq$ \textit{règle\_vide}}{
      \Assign{$R'$}{\Child{$R'$}{\textit{suivant}}}
    }

    \tcp{$R'$ contient désormais le dernier élément de la liste}

    \textit{mettre\_suivant}($R'$, \textit{nouvelle\_règle(\textit{symbole}, \textit{règle\_vide})})
  }
}

\caption{AjoutPrémisse\label{AP}}
\end{algorithm}

% 1.3
\subsection{Créer la conclusion d'une règle}

Créer la conclusion d'une règle revient à ajouter une proposition (symbole) à la fin de la règle.
Pour ce faire, nous ré-utilisons l'algorithme \hyperref[AP]{AjoutPrémisse} défini plus tôt.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à modifier} \\
  \Arg{\textit{symbole}}{Le nom de la proposition (symbole) à insérer comme conclusion}
}
\Data{\Arg{$R$}{Règle}, \Arg{\textit{symbole}}{Chaîne de charactères}}
\Result{\Arg{$R$}{Règle}}

\Begin({AjoutConclusion($R$, \textit{symbole})}){
  \Assign{$R$}{\hyperref[AP]{AjoutPrémisse}($R$, \textit{symbole})}
}

\caption{AjoutConclusion\label{AC}}
\end{algorithm}

% 1.4
\subsection{Tester si une proposition appartient à la prémisse d'une règle}

Nous testons si une proposition appartient à la prémisse d'une règle en traversant celle-ci de manière récursive (contrainte du projet).

Les 3 cas minimaux sont:

\begin{description}
  \item[$R$ = {[]}] (règle vide): retourner \og Faux \fg
  \item[$R$ = \{symbole: "...", suivant: \textit{règle\_vide}\}] (conclusion): retourner \og Faux \fg
  \item[$R$ = \{symbole: symbole\_recherché, suivant: ...\}] (symbole trouvé): retourner \og Vrai \fg
\end{description}

Dans les autres cas, nous retournons de manière récursive le résultat de la même fonction, appelée sur \Child{$R$}{\textit{suivant}}.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{\textit{symbole}}{La nom de la proposition à rechercher} \\
  \Arg{\textit{résultat}}{Si oui ou non la proposition à été trouvée}
}
\Data{\Arg{$R$}{Règle}, \Arg{\textit{symbole}}{Chaîne de charactères}}
\Result{\Arg{\textit{résultat}}{Booléen}}

\Begin({TestAppartenance($R$, \textit{symbole})}){
  \uIf{$R$ = \textit{règle\_vide}}{
    \tcp{Règle vide}
    \Assign{\textit{résultat}}{Faux}
  }
  \uElseIf{\Child{$R$}{\textit{suivant}} = \textit{règle\_vide}}{
    \tcp{Conclusion}
    \Assign{\textit{résultat}}{Faux}
  }
  \uElseIf{\Child{$R$}{\textit{symbole}} = \textit{symbole}}{
    \tcp{Symbole trouvé}
    \Assign{\textit{résultat}}{Vrai}
  }
  \Else{
    \Assign{\textit{résultat}}{TestAppartenance(\Child{$R$}{\textit{suivant}}, \textit{symbole})}
  }
}

\caption{TestAppartenance\label{TA}}
\end{algorithm}

% 1.5
\subsection{Supprimer une proposition de la prémisse d'une règle}

Nous supprimons une proposition de la prémisse d'une règle de manière récursive.
Les cas minimaux sont les suivants:

\begin{description}
  \item[$R$ = {[]}] (règle vide): retourner \textit{règle\_vide}
  \item[$R$ = \{symbole: "...", suivant: \textit{règle\_vide}\}] (conclusion): retourner $R$
\end{description}

Dans le cas général, nous attribuons à \Child{$R$}{\textit{suivant}} la valeur retournée par cette fonction, appelée sur \Child{$R$}{\textit{suivant}}, et nous retournons \Child{$R$}{\textit{suivant}} si le noeud correspond au symbole et $R$ sinon.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à modifier} \\
  \Arg{\textit{symbole}}{La nom de la proposition à rechercher} \\
  \Arg{$R'$}{La règle privée de \textit{symbole} dans sa prémisse}
}
\Data{\Arg{$R$}{Règle}, \Arg{\textit{symbole}}{Chaîne de charactères}}
\Result{\Arg{$R'$}{Règle}}

\Begin({SupprimerSymbole($R$, \textit{symbole})}){
  \uIf{$R$ = \textit{règle\_vide}}{
    \tcp{Règle vide}
    \Assign{$R'$}{\textit{règle\_vide}}
  }
  \uElseIf{\Child{$R$}{\textit{suivant}} = \textit{règle\_vide}}{
    \tcp{Conclusion}
    \Assign{$R'$}{$R$}
  }
  \Else{
    \uIf{\Child{$R$}{\textit{symbole}} = \textit{symbole}}{
      \tcp{Retourner le reste de la liste, sans ce noeud}
      \Assign{$R'$}{SupprimerSymbole(\Child{$R$}{\textit{suivant}}, \textit{symbole})}
    }
    \Else{
      \Assign{$R'$}{\textit{mettre\_suivant}($R$, SupprimerSymbole(\Child{$R$}{\textit{suivant}}, \textit{symbole}))}
    }
  }
}

\caption{SupprimerSymbole\label{SS}}
\end{algorithm}

% 1.6
\subsection{Tester si la prémisse d'une règle est vide}

Voici la fonction retournant \og Vrai \fg si la prémisse d'une règle est vide et \og Faux \fg si la prémisse d'une règle contient au moins 1 symbole:

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{\textit{résultat}}{Si oui ou non la prémisse d'une règle est vide}
}
\Data{\Arg{$R$}{Règle}}
\Result{\Arg{\textit{résultat}}{Booléen}}

\Begin({PrémisseVide($R$)}){
  \uIf{$R$ = \textit{règle\_vide}}{
    \tcp{La règle est vide, donc sa prémisse est vide}
    \Assign{\textit{résultat}}{Vrai}
  }
  \uElseIf{\Child{$R$}{\textit{suivant}} = \textit{règle\_vide}}{
    \tcp{La règle n'a qu'une conclusion, donc sa prémisse est vide}
    \Assign{\textit{résultat}}{Vrai}
  }
  \Else{
    \Assign{\textit{résultat}}{Faux}
  }
}

\caption{PrémisseVide\label{PV}}
\end{algorithm}

% 1.7
\subsection{Accéder à la proposition se trouvant en tête d'une prémisse}

Voici la fonction retournant la valeur de la proposition se trouvant en tête d'une prémisse.
Si la prémisse est vide, alors la fonction retourne \textit{règle\_vide}.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{\textit{résultat}}{La valeur du premier symbole de la prémisse, si existant}
}
\Data{\Arg{$R$}{Règle}}
\Result{\Arg{\textit{résultat}}{Chaîne de charactères}}

\Begin({PremierSymbole($R$)}){
  \uIf{\hyperref[PV]{PrémisseVide}($R$)}{
    \tcp{La prémisse est vide: nous retournons \textit{règle\_vide}}
    \Assign{\textit{résultat}}{\textit{règle\_vide}}
  }
  \Else{
    \Assign{\textit{résultat}}{\Child{$R$}{\textit{symbole}}}
  }
}

\caption{PremierSymbole\label{PS}}
\end{algorithm}

% 1.8
\subsection{Accéder à la conclusion d'une règle}

La conclusion se trouvant à la fin d'une règle, nous traversons simplement la liste chaînée jusqu'au dernier élément de celle-ci.
Si la liste est vide, alors la fonction retourne \textit{règle\_vide}.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{$R'$}{Variable temporaire pour traverses la liste chaînée} \\
  \Arg{\textit{résultat}}{La valeur du premier symbole de la prémisse, si existant}
}
\Data{\Arg{$R$}{Règle}}
\Result{\Arg{\textit{résultat}}{Chaîne de charactères}}

\Begin({ConclusionRegle($R$)}){
  \uIf{\Child{$R$}{\textit{suivant}} = \textit{règle\_vide}}{
    \Assign{\textit{résultat}}{\textit{règle\_vide}}
  }
  \Else{
    \Assign{$R'$}{$R$}

    \tcp{Avançer jusqu'à la fin de la liste}
    \While{\Child{$R'$}{\textit{suivant}} $\neq$ \textit{règle\_vide}}{
      \Assign{$R'$}{\Child{$R'$}{\textit{suivant}}}
    }

    \Assign{\textit{résultat}}{\Child{$R'$}{\textit{symbole}}}
  }
}

\caption{ConclusionRegle\label{CR}}
\end{algorithm}

% 2
\section{Base de Connaissance}

Soit \textbf{BC} le type représentant une base de connaissance; celle-ci prend la forme d'une liste chaînée de Règles:

\begin{tabular}{|p{3cm}|p{4cm}|p{6.5cm}|}
  \hline
  \multicolumn{3}{|c|}{\textbf{Structure 2 :} BC\label{BC}} \\
  \hline
  \textbf{Nom} & \textbf{Type} & \textbf{Description} \\
  \hline
  \textit{règle} & BC $\rightarrow$ Règle & Retourne une référence à la règle correspondant à ce noeud. \\
  \hline
  \textit{suivant} & BC $\rightarrow$ BC & Une référence au prochain élément de la liste chaînée, \Null si l'élément est le dernier de la liste. \\
  \hline
  \textit{nouvelle\_base} & (Règle $\cross$ BC) $\rightarrow$ BC & Crée une nouvelle base à partir d'une référence vers une Règle et d'une référence vers BC \\
  \hline
  \textit{base\_vide} & BC & La base vide \\
  \hline
\end{tabular}

Les axiomes sur ces fonctions sont:

\begin{itemize}
\item \textit{règle}(\textit{nouvelle\_base}(r, b)) = r
\item \textit{suivant}(\textit{nouvelle\_base}(r, b)) = b
\end{itemize}

% 2.1
\subsection{Créer une base vide}

Nous représentons une base vide par \textit{base\_vide}.
Voici l'algorithme permettant de créer une base vide:

\begin{algorithm}[H]
\Vars{\Arg{$B$}{La base vide à retourner}}
\Result{\Arg{$B$}{BC}}

\Begin({BaseVide()}){
  \Assign{$B$}{\textit{base\_vide}}
}

\caption{BaseVide\label{BV}}
\end{algorithm}

% 2.2
\subsection{Ajouter une règle à une base de connaissance}

L'ajout de règle à la base de connaissance se fait en tête. Voici son algorithme:

\begin{algorithm}[H]
\Vars{
  \Arg{$B$}{La base de connaissance à modifier} \\
  \Arg{\textit{règle}}{La valeur de \textit{règle} à mettre dans le noeud} \\
  \Arg{$B'$}{La base de connaissance contenant la nouvelle règle}
}
\Data{\Arg{$B$}{BC}; \Arg{\textit{règle}}{Règle}}
\Result{\Arg{$B'$}{BC}}
\Begin({AjoutRègle($B$, \textit{règle})}){
  \Assign{$B'$}{\textit{nouvelle\_base}}(\textit{règle}, $B$)}
}

\caption{AjoutRègle\label{AR}}
\end{algorithm}

% 2.3
\subsection{Accéder à la règle se trouvant en tête de la base}

L'ajout de règle à la base de connaissance se fait en tête. Voici son algorithme:

\begin{algorithm}[H]
\Vars{
  \Arg{$B$}{La base de connaissance à modifier} \\
  \Arg{$R$}{La règle se trouvant en tête de la base, \textit{règle\_vide} si la base est vide}
}
\Data{\Arg{$B$}{BC}}
\Result{\Arg{$R$}{Règle}}
\Begin({TêteBase($B$)}){
  \uIf{\Child{$B$}{\textit{suivant}} = \textit{base\_vide}}{
    \Assign{$R$}{\textit{règle\_vide}}
  }
  \Else{
    \Assign{$R$}{\textit{règle}}($B$)}
  }
}

\caption{TêteBase\label{TB}}
\end{algorithm}

\end{document}
