\documentclass[12pt]{article}

\setlength{\parskip}{1em}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[a4paper, margin=1in]{geometry}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue,
  pdftitle={Projet LO21: Rapport final}
}

\usepackage{listings}
\lstset{
  numbers=left,
  columns=fullflexible,
  language=C,
  numberstyle=\scriptsize,
}

\usepackage[linesnumbered, french]{algorithm2e}
\SetKwInput{Data}{Donn\'ees}
\SetKwInput{Result}{R\'esultat}
\SetKwInput{Vars}{Variables}
\SetKwIF{If}{ElseIf}{Else}{Si}{alors}{Sinon si}{Sinon}{FinSi}
\SetKwFor{While}{Tant que}{faire}{Fin TantQue}
\SetKwBlock{Begin}{D\'ebut}{Fin}
\DontPrintSemicolon
\SetAlgoLined

\RestyleAlgo{boxruled}

\newcommand{\Assign}[2]{#1 $\; \longleftarrow \;$ #2}
\newcommand{\Arg}[2]{\hspace{0.2em}#1\hspace{0.05em}: #2}
\newcommand{\Child}[2]{(#1 $\rightarrow$ #2)}


\title{Projet LO21: Rapport final}
\author{Adrien Burgun}
\date{Automne 2020}
\graphicspath{{report/}}

\begin{document}

\maketitle

\begin{abstract}

  Le projet de ce semestre pour le cours de \textbf{LO21} (Algorithmique et Programmation II) porte sur un \textit{\og système expert \fg}.
  Un système expert est constitué de 3 éléments:

  \begin{description}[align=left]
    \item [Une base de connaissance,] qui prend la forme suivante:
    \[
      A \wedge B \wedge ... \wedge Z \Rightarrow \Omega
    \]
    Où \(A, B, ...\) sont les symboles (d'arité zéro, aussi appelés \og propositions \fg) constituant la \textit{prémisse} et \(\Omega\) est la \textit{conclusion}.

    \item [Une base de faits,] qui est la liste des symboles ayant la valeur \textit{\og Vrai \fg} (qui correspond à l'état \textit{\og Certain \fg}). \\
    Un symbole ne faisant pas partie de cette liste a par défaut la valeur \textit{\og Faux \fg} (qui correspond à l'état \textit{\og Incertain \fg}).

    \item [Un moteur d'inférence,] qui, à partir de la base de connaissance et la base de faits, déduit quels autres symboles sont aussi vrais et les ajoute à la base de faits.
  \end{description}

  Nous définirons d'abords le type \textit{\og Règle \fg}, constituant la base de connaissance. \\
  Nous définirons ensuite le type \textit{\og BC \fg} (\underline{B}ase de \underline{C}onnaissance). \\
  Nous décrirons enfin le moteur d'inférence comme implémenté dans ce projet, avec différents exemples.
\end{abstract}

\section{Règles}

Soit \textit{regle\_t} le type représentant une règle sous la forme d'une liste chaînée de symboles:

% Faire un tableau?

% \begin{lstlisting}
% #define LONGUEUR_SYMBOLE 256

% struct regle {
%   char symbole[LONGUEUR_SYMBOLE];
%   struct regle* suivant;
% };

% typedef struct regle regle_t;
% \end{lstlisting}

L'implémentation faite dans ce projet utilise des noms anglais pour les variables, fonctions et types; le type \textit{Règle} a pour équivalent C le type \textit{rule\_t}.
% Une liste des traductions en anglais peut être trouvée à la fin de ce document.

Le dernier élément d'une telle liste chaînée correspond à la conclusion de la règle, tandis que tous les autres éléments appartiennent à la prémisse (contrainte du projet).

\subsection{Créer une règle vide}

Nous représenterons une règle vide par un pointeur nul.
Voici l'algorithme permettant de créer une règle vide:

\begin{algorithm}[H]
\Vars{\Arg{$R$}{La règle vide à retourner}}
\Result{\Arg{$R$}{Règle}}

\Begin({NouvelleRègle()}){
  \Assign{$R$}{NULL}
}

\caption{NouvelleRègle\label{NR}}
\end{algorithm}

\subsection{Créer un noeud d'une règle}

Voici la fonction permettant de créer un noeud (ou symbole) dans une règle:

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{Le noeud de la règle à retourner} \\
  \Arg{$symbole$}{La valeur de $symbole$ à mettre dans le noeud} \\
  \Arg{$suivant$}{Pointeur sur le prochain noeud de la liste}
}
\Data{\Arg{$symbole$}{Chaîne de charactères}; \Arg{$suivant$}{Règle}}
\Result{\Arg{$R$}{Règle}}

\Begin({CréerNoeud($symbole$, $suivant$)}){
  \tcp{Nous supposons que l'espace de mémoire requis pour $R$ est déjà alloué}

  \Assign{\Child{$R$}{$symbole$}}{$symbole$}

  \Assign{\Child{$R$}{$suivant$}}{$suivant$}
}

\caption{CréerNoeud\label{CN}}
\end{algorithm}

\subsection{Ajouter une proposition à la prémisse d'une règle}

% Je me permets d'interrompre votre brave lecture de ce document latex pour argumenter sur la question posée dans le sujet original, qui stipule que cet ajout doit se faire en *queue*, et non pas en *tête*.
% Voici donc des exemples d'utilisations de cette fonction et les résultats auxquels on s'attendrait (1) par rapport aux résultats qu'on obtiendra avec cette contrainte (2):
%
% ajout_prémisse(ø, A) -> (1) A | ø, (2) ø | A
% ajout_prémisse(ø | A, B) -> (1) B | A; (2) A | B
% ajout_prémisse(A & B | Ω, C) -> (1) C & A & B | Ω; (2) A & B & Ω | C
%
% Le problème est, à mon avis, qu'ajouter un symbole à la prémisse d'une règle ne devrait pas affecter la conclusion d'une règle, ce qui n'est pas le cas lorsque l'ajout se fait à l'endroit dédié à la conclusion de la règle.
% Cela voudra aussi dire que la fonction pour ajouter une conclusion à une règle sera identique à celle-ci.

L'ajout des propositions (symboles) à la prémisse d'une règle se fait par l'algorithme \textit{AjoutPrémisse} défini ci-dessous.
Cet ajout se fait en queue de la liste chaînée (contrainte du projet).
La liste chaînée donnée en entrée est modifiée par l'algorithme et est retournée.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à modifier} \\
  \Arg{$R'$}{Une variable temporaire pour traverser la liste chaînée} \\
  \Arg{$symbole$}{Le nom de la proposition (symbole) à insérer}
}
\Data{\Arg{$R$}{Règle}, \Arg{$symbole$}{Chaîne de charactères}}
\Result{\Arg{$R$}{Règle}}

\Begin({AjoutPrémisse($R$, $symbole$)}){
  \uIf{$R$ = NULL}{
    \Assign{$R$}{\hyperref[CN]{CréerNoeud}($symbole$, NULL)}
  }
  \Else{
    \Assign{$R'$}{R}

    \tcp{Répeter jusqu'à ce qu'on atteigne le dernier élément}

    \While{\Child{$R'$}{$next$} = NULL}{
      \Assign{$R'$}{\Child{$R'$}{$next$}}
    }

    \tcp{$R'$ contient désormais le dernier élément de la liste}

    \Assign{\Child{$R'$}{suivant}}{\hyperref[CN]{CréerNoeud}($symbole$, NULL)}
  }
}

\caption{AjoutPrémisse\label{AP}}
\end{algorithm}

\subsection{Créer la conclusion d'une règle}

Créer la conclusion d'une règle revient à ajouter une proposition (symbole) à la fin de la règle.
Pour ce faire, nous ré-utilisons l'algorithme \hyperref[AP]{AjoutPrémisse} défini plus tôt.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à modifier} \\
  \Arg{$symbole$}{Le nom de la proposition (symbole) à insérer comme conclusion}
}
\Data{\Arg{$R$}{Règle}, \Arg{$symbole$}{Chaîne de charactères}}
\Result{\Arg{$R$}{Règle}}

\Begin({AjoutConclusion($R$, $symbole$)}){
  \Assign{$R$}{\hyperref[AP]{AjoutPrémisse}($R$, $symbole$)}
}

\caption{AjoutConclusion\label{AC}}
\end{algorithm}

\subsection{Tester si une proposition appartient à la prémisse d'une règle}

Nous testons si une proposition appartient à la prémisse d'une règle en traversant celle-ci de manière récursive (contrainte du projet).

Les 3 cas minimaux sont:

\begin{description}
  \item[$R$ = {[]}] (règle vide): retourner \og Faux \fg
  \item[$R$ = \{symbole: "...", suivant: NULL\}] (conclusion): retourner \og Faux \fg
  \item[$R$ = \{symbole: symbole\_recherché, suivant: ...\}] (symbole trouvé): retourner \og Vrai \fg
\end{description}

Dans les autres cas, nous retournons de manière récursive le résultat de la même fonction, appelée sur \Child{$R$}{$suivant$}.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{$symbole$}{La nom de la proposition à rechercher} \\
  \Arg{\textit{résultat}}{Si oui ou non la proposition à été trouvée}
}
\Data{\Arg{$R$}{Règle}, \Arg{$symbole$}{Chaîne de charactères}}
\Result{\Arg{\textit{résultat}}{Booléen}}

\Begin({TestAppartenance($R$, $symbole$)}){
  \uIf{$R$ = NULL}{
    \tcp{Règle vide}
    \Assign{\textit{résultat}}{Faux}
  }
  \uElseIf{\Child{$R$}{$suivant$} = NULL}{
    \tcp{Conclusion}
    \Assign{\textit{résultat}}{Faux}
  }
  \uElseIf{\Child{$R$}{$symbole$} = $symbole$}{
    \tcp{Symbole trouvé}
    \Assign{\textit{résultat}}{Vrai}
  }
  \Else{
    \Assign{\textit{résultat}}{TestAppartenance(\Child{$R$}{$suivant$}, $symbole$)}
  }
}

\caption{TestAppartenance\label{TA}}
\end{algorithm}

\subsection{Supprimer une proposition de la prémisse d'une règle}

Nous supprimons une proposition de la prémisse d'une règle de manière récursive.
Les cas minimaux sont les suivants:

\begin{description}
  \item[$R$ = {[]}] (règle vide): retourner NULL
  \item[$R$ = \{symbole: "...", suivant: NULL\}] (conclusion): retourner $R$
\end{description}

Dans le cas général, nous attribuons à \Child{$R$}{$suivant$} la valeur retournée par cette fonction, appelée sur \Child{$R$}{$suivant$}, et nous retournons \Child{$R$}{$suivant$} si le noeud correspond au symbole et $R$ sinon.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à modifier} \\
  \Arg{$symbole$}{La nom de la proposition à rechercher} \\
  \Arg{$R'$}{La règle privée de $symbole$ dans sa prémisse}
}
\Data{\Arg{$R$}{Règle}, \Arg{$symbole$}{Chaîne de charactères}}
\Result{\Arg{$R'$}{Règle}}

\Begin({SupprimerSymbole($R$, $symbole$)}){
  \uIf{$R$ = NULL}{
    \tcp{Règle vide}
    \Assign{$R'$}{NULL}
  }
  \uElseIf{\Child{$R$}{$suivant$} = NULL}{
    \tcp{Conclusion}
    \Assign{$R'$}{$R$}
  }
  \Else{
    \uIf{\Child{$R$}{$symbole$} = $symbole$}{
      \tcp{Retourner le reste de la liste, sans ce noeud}
      \Assign{$R'$}{SupprimerSymbole(\Child{$R$}{$suivant$}, $symbole$)}
    }
    \Else{
      \Assign{\Child{$R$}{$suivant$}}{SupprimerSymbole(\Child{$R$}{$suivant$}, $symbole$)}

      \Assign{$R'$}{$R$}
    }
  }
}

\caption{SupprimerSymbole\label{SS}}
\end{algorithm}

\subsection{Tester si la prémisse d'une règle est vide}

Voici la fonction retournant \og Vrai \fg si la prémisse d'une règle est vide et \og Faux \fg si la prémisse d'une règle contient au moins 1 symbole:

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{\textit{résultat}}{Si oui ou non la prémisse d'une règle est vide}
}
\Data{\Arg{$R$}{Règle}}
\Result{\Arg{\textit{résultat}}{Booléen}}

\Begin({PrémisseVide($R$)}){
  \uIf{$R$ = NULL}{
    \tcp{La règle est vide, donc sa prémisse est vide}
    \Assign{\textit{résultat}}{Vrai}
  }
  \uElseIf{\Child{$R$}{$suivant$} = NULL}{
    \tcp{La règle n'a qu'une conclusion, donc sa prémisse est vide}
    \Assign{\textit{résultat}}{Vrai}
  }
  \Else{
    \Assign{\textit{résultat}}{Faux}
  }
}

\caption{PrémisseVide\label{PV}}
\end{algorithm}

\subsection{Accéder à la proposition se trouvant en tête d'une prémisse}

Voici la fonction retournant la valeur de la proposition se trouvant en tête d'une prémisse.
Si la prémisse est vide, alors la fonction retourne NULL.

\begin{algorithm}[H]
\Vars{
  \Arg{$R$}{La règle à étudier} \\
  \Arg{\textit{résultat}}{La valeur du premier symbole de la prémisse, si existant}
}
\Data{\Arg{$R$}{Règle}}
\Result{\Arg{\textit{résultat}}{Chaîne de charactères}}

\Begin({PremierSymbole($R$)}){
  \uIf{\hyperref[PV]{PrémisseVide}($R$)}{
    \tcp{La prémisse est vide: nous retournons NULL}
    \Assign{\textit{résultat}}{NULL}
  }
  \Else{
    \Assign{\textit{résultat}}{\Child{$R$}{$symbole$}}
  }
}

\caption{PremierSymbole\label{PS}}
\end{algorithm}

\end{document}
